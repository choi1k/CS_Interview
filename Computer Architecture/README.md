# CPU(Core Processing Unit)와 CPU 동작 프로세스
CPU(중앙처리장치)는 크게 제어장치, 연산장치, 레지스터로 구성되어 있음

### 제어장치
  
* 제어장치란?

   CPU 내부에서 일어나는 모든 작업을 제어함. 명령을 꺼내 해독하고 시스템 전체에 신호를 보냄
  
  주기억장치에서 프로그램 명령어를 꺼내 이를 해독하고 실행에 필요한 제어신호를 기억장치, 연산장치, 입출력장치로 보냄
  
  이후 이들로부터 받은 신호를 바탕으로 다음 수행할 동작을 결정함
  
* 제어장치 종류
  
      프로그램 카운터(Program Counter) : 다음에 수행할 명령어의 주소를 기억하는 레지스터
  
      명령 해독기(Instruction Decoder) : 수행해야 할 명령어를 해석해 부호기로 전달하는 회로
  
      부호기(Encoder) : 명령 해독기에 전송된 명령어를 제어 필요한 신호로 변환하는 회로
  
      주소 해독기(Address Decoder) : 명령 레지스터에서 온 주소를 해석하는 회로
  
      명령 레지스터(IR : Instruction Register) : 현재 수행중인 명령어를 기억하는 레지스터
  
      메모리 주소 레지스터(MAR : Memory Buffer Register) : 연산을 수행할 주기억장치 주소를 저장하는 레지스터
  
      메모리 버퍼 레지스터(MBR : Memory Buffer Register) : 주기억장치에서 읽어온 데이터와 임시저장데이터를 저장하는 레지스터
  
### 연산장치 

* 연산장치란?

  산술논리연산장치로서 산술연산(+, -, *, /)과 논리연산(true/false)을 수행함
 
  레지스터에서 연산에 필요한 데이터를 가져오고 연산 결과는 다시 레지스터로 보냄
  
* 연산장치 종류
  
      가산기(Adder) : 누산기와 데이터레지스터에 보관된 값을 더하는 회로
  
      누산기(Accumulator) : 연산의 결과를 일시적으로 보관하는 레지스터
  
      보수기(Complementor) : 뺄셈을 위해 보수로 변경해주는 회로
  
      데이터 레지스터(Data Register) : 연산한 데이터를 기억하는 레지스터
  
      상태 레지스터(Status Register) : 명령어 실행 중 발생하는 CPU의 상태 정보를 저장하는 레지스터
  
### 레지스터

* 레지스터란?

  CPU에 사용되는 데이터를 임시 저장함
  
  명령어 주소, 코드, 연산에 필요한 데이터, 연산결과를 임시로 저장
  
  가장 빠른 고속기억장치로 읽기/쓰기가 모두 가능함
  
* 레지스터 종류

  제어장치 관련 : 
  
      프로그램 카운터(Program Counter)
      
      명령 레지스터(Instruction Register)
      
      메모리 주소 레지스터(MAR)
      
      메모리 버퍼 레지스터(MBR)
      
  연산장치 관련 : 
  
      데이터 레지스터(Data Register)
  
      상태 레지스터(Status Register)
      
  ### CPU 동작 과정
  
      1. 주기억장치는 입력장치에서 읽어온 데이터나 보조기억장치에 저장된 프로그램을 읽어옴
      
      2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리한 뒤, 
         그 결과를 다시 주기억장치에 저장함
      
      3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력 장치로 보냄
      
      4. 제어장치는 위의 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어함.
      
* 명령어 세트
    
  CPU가 실행할 명령어의 집합
    
      명령어 세트 = 연산 코드(Operation Code) + 피연산자(Operand)
        
      연산 코드 : 실행할 연산
        
      피연산자 : 필요한 데이터, 저장 위치
        
* 명령어 사이클
    
  CPU가 주기억장치에서 하나의 명령어를 읽어와 수행하는 일련의 과정
    
  인출, 실행, 간접, 인터럽트 사이클이 존재
    
  * 인출
    
  1. PC에 저장된 주소를 MAR로 전달
    
  2. 저장된 내용을 바탕으로 주기억장치에서 해당 주소의 명령어 인출
    
  3. 인출한 명령어 MBR에 저장
    
  4. 다음 명령어를 인출하기 위해 PC 값 증가
    
  5. MBR에 저장된 내용 IR에 전달
    
         T0 : MAR <- PC     
         T1 : MBR <- M[MAR]         
         T2 : IR <- MBR
    
  * 실행
    
    인출이 진행된 상태이기 때문에 PC 증가 불필요
    
    IR에 MBR의 값이 저장되어 있어 AC에 MBR을 더해주기만 하면 됨
  
        T0 : MAR <- IR(Addr)
        T1 : MBR <- MBR <- M[MAR]
        T2 : AC <- AC + MBR

# 캐시 메모리(Cache Memory)
캐시 메모리는처리 속도가 다른 두 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리임

RAM에서 데이터를 인출해오는 속도가 CPU가 task를 처리하는 속도보다 느리기 때문에 시간이 낭비되지만,\
중간에 위치한 캐시 메모리가 둘 사이에서 데이터를 고속으로 전달해줌으로써 속도 차이로 인한 병목을 어느정도 해결해 줌

CPU가 주기억장치에 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장해둠

이후 태스크 수행 시 주기억장치가 아닌 캐시 메모리에서 데이터를 먼저 가져옴으로써 속도를 향상시킴

빠른 속도가 장점이지만, 용량이 적고 비용이 비쌈

CPU에는 L1, L2, L3 캐시 메모리가 사용됨 (L = Level)

속도와 크기에 따라 분류되며 일반적으로 L1부터 접근하고 원하는 데이터를 얻지 못하면 L2로 가게 됨

### 캐시 메모리의 지역성(Cache Locality)

지역성 : 시/공간적으로 가까운 데이터의 접근이 다른 데이터보다 접근이 원활하게 일어나는 특성

해당 특성으로 적중률을 최대화하여 효율적 동작을 가능하게 함

  * 공간 지역성 : 배열과 같은 구조 내에서 최근 사용했던 데이터와 메모리 주소상 인접한 데이터가 잠시후 참조될 가능성이 높다는 특성
  
  * 시간 지역성 : for나 while과 같은 반복문에 사용된 변수와 같이 최근 사용된 데이터는 잠시후 또 다시 참조될 가능성이 높다는 특성
  
  이와 같은 특성으로 인해 캐시에 데이터를 저장할 때는 해당 데이터 외에도 옆 주소의 데이터도 함께 가져와 추후 사용에 대해 대비함
  
### 캐싱 라인(Caching Line)

캐시가 메모리에서 CPU로 데이터를 빠르게 전달해도 캐시 내부에서 데이터를 찾을 때 오랜 시간이 걸린다면 캐시의 효과를 기대할 수 없음

따라서 캐시는 데이터를 쉽게 검색하기 위해 사용되는 데이터의 주소를 기록해둔 태그를 만듦

이러한 태그들을 하나로 묶은 자료구조를 캐싱 라인이라고 함

  * 직접 매핑(Direct Mapping)
  
    메인 메모리를 일정한 블록으로 나눠 각각의 블록을 캐시의 정해진 영역에 매핑하는 방식
    
    구현이 가장 쉽다는 장점이 있지만,
    캐시 적중률이 낮아질 수 있고 하나의 캐시 메모리에서 참조하는 데이터가 둘 이상이 될 수 있어 충돌 발생 가능성이 존재함
    
  * 완전 연관 매핑(Fully Associative Mapping)
  
    캐시 메모리의 빈 공간에 마음대로 주소를 매핑하는 방식
    
    간단하지만 캐시 메모리에서 데이터를 꺼내올 때 모든 데이터를 순회하는 병렬 검색이 진행됨
    
    이를 해결하기 위해 CAM(Content-Addressable Memory)이라는 특수한 형태의 메모리가 추가로 필요해 비용이 비쌈
    
  * 집합 연관 매핑(Set AssociativeMapping)
  
    직접 매핑 + 연관 매핑의 방식
    
    캐시 메모리의 빈 공간에 마음대로 주소를 저장하되, 미리 정해둔 특정 여역에만 저장하는 방식
    
    직접 매핑에 비해 검색은 느리지만 저장이 빠르고,
    완전 연관 매핑에 비해 검색은 빠르지만 저장이 느려 편향되지 않은 성능을 보장함
    
### 캐시 미스
  
  CPU가 요청한 데이터가 캐시에 있으면 Cache Hit, 없어서 DRAM에서 가져오면 Cache Miss
  
  * Cold Start Miss : 데이터에 처음 접근해 캐시에 해당 데이터를 새롭게 올릴 때 발생하는 미스
  
  * Conflict Miss : Direct map 이나 Set Associative 방식에서 같은 부분을 번갈아 가면서 사용하게 되어 발생하는 미스
  
  * Capacity Miss : 캐시의 용량이 부족해 발생하는 미스

# 고정 소수점(fixed point) 과 부동 소수점(floating point)
컴퓨터에서 실수를 표현하는 방법은 고정 소수점과 부동 소수점 두가지 방식이 존재

### 고정 소수점

실수를 정수부, 소수부로 나누고 소수부 자릿수를 미리 정하여 고정된 자릿수의 실수를 표현한 것

실수를 표현하는 가장 간단한 방식

정수부와 소수부의 자릿수가 크지 않기 때문에 표현 범위가 매우 적음

    32bit 실수 = 1bit(부호) + 15bit(정수부) + 16bit(소수부)
    
    ex) -45.7812

### 부동 소수점

실수를 가수부, 지수부로 나누고 지수 값에 따라 소수점이 움직이는 실수를 표현한 것

자릿수가 제한된 고정 소수점 방식과 달리 표현 범위가 매우 큼

소수점이 움직이기 때문에 오차 발생 위험이 있음

    32bit 실수 = 1bit(부호) + 8bit(지수부) + 23bit(가수부)
    
    ex) -3.14e16