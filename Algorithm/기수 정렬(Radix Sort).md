# 기수 정렬(Radix Sort)

### 기수 정렬이란?

기수 정렬은 비교연산을 수행하지 않아 조건이 맞는 상황에서 빠른 정렬 속도를 보장하는 알고리즘임\
데이터의 각 자릿수를 낮은 자리수부터 가장 높은 자리수까지 올라가면서 정렬을 수행하며 자릿수가 존재하지 않는 데이터는 기수 정렬이 불가함

### 과정

1. 큐(Queue)를 활용해 기수만큼 저장공간 Bucket을 생성함

2. 데이터의 1의 자리를 기준으로 버킷에 넣음

3. 버킷에 저장된 데이터를 순서대로 꺼내 기존 데이터에 덮어씀

4. 데이터의 10의 자리를 기준으로 버킷에 넢음

5. 주어진 데이터 중 최대 자릿수까지 이와 같은 과정을 반복함

### 코드(Java)

```Java
static void radixSort(int[] arr) {
  ArrayDeque<Integer>[] buckets = new ArrayDeque[10];
  for(int i=0;i<10;i++) {
    buckets[i] = new ArrayDeque<>();
  }
  
  int div = 10;
  while(div < 100000) {  // 데이터 최고 자릿수가 10000이하인 경우
    for(int i=0;i<arr.length;i++) 
      buckets[(arr[i]/div)%10].offer(arr[i]);


    for(int i=0, bi=0;i<10;i++) {
      while(buckets[bi].isEmpty())
        bi++;
      arr[i]=buckets[bi].poll();
    }
    div *= 10;
  }	
}
```

* 장점
  
  * 문자열, 정수 정렬 가능
  * <b>안정 정렬(Stable Sort)</b>임(정렬 이후 중복된 값들은 자리가 바뀌지 않음)\
    전) 8, 5(A), 36, 5(B), 23 -> 후) 5(A), 5(B), 8, 23, 36
  * 성능이 빠름
  
* 단점

  * 데이터에 자릿수가 없다면 정렬할 수 없음\
    ex) 부동 소수점
  * 중간 결과를 저장할 bucket이라는 공간이 필요함\
    bucket의 크기는 정렬 대상에 따라(10진수 : 10개, 알파벳 : 26개)달라지기 때문에 모든 케이스에 맞게 정의할 수는 없음
  
### 시간 복잡도

* 최선 : O(dN)
* 최악 : O(dN)\
  d = 데이터의 최대 자릿수, N = 데이터의 개수\
  (버킷에 데이터를 넣고 빼는 작업(N)을 최대 자릿수(d)만큼 반복 수행함)

